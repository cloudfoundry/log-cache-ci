#!/bin/bash

set -e

warning() {
  YELLOW='\033[0;33m'
  CLEAR='\033[0m'
  local message=${1}

  echo -e "${YELLOW}${message}${CLEAR}"
}

function check_lpass {
    echo -n "Checking lpass ... "
    lpass status
}

function find_pipeline {
    echo -n "Finding pipeline ..."
    query=${1}
    pipeline_dir='pipelines/'

    pushd ${pipeline_dir} > /dev/null
        pipelines=()
        top_level_pipelines=()

        while IFS=  read -r -d $'\n'; do
            normalized_pipeline=`echo ${REPLY} | cut -c 3-`
            top_level_pipelines+=("$normalized_pipeline")
        done < <(find . -maxdepth 1 -type f \( ! -name . \) | sort)

        while IFS=  read -r -d $'\0'; do
            normalized_pipeline=`echo ${REPLY} | cut -c 3-`
            pipelines+=($normalized_pipeline)
        done < <(find . -mindepth 2 -type f \( ! -name . \) -print0)
    popd > /dev/null

    pipeline=''

    if [[ ${query} != '' ]]; then
        # top level pipeline starts with query
        for p in "${top_level_pipelines[@]}"; do
            if [[ "${p}" == "${query}"* ]]; then
                pipeline=${p}
            fi
        done

        # top level pipeline substring matches query
        if [[ ${pipeline} = '' && ${#matching_pipelines[@]} -eq 0 ]]; then
            for p in "${top_level_pipelines[@]}"; do
                if [[ "${p}" =~ "${query}" ]]; then
                    pipeline=${p}
                fi
            done
        fi

        # any pipeline substring matches query
        matching_pipelines=()
        if [[ ${pipeline} = '' && ${#matching_pipelines[@]} -eq 0 ]]; then
            for p in "${pipelines[@]}"; do
                if [[ "${p}" =~ "${query}" ]]; then
                    matching_pipelines+=("${p}")
                fi
            done
        fi
    fi

    if [[ ${pipeline} = '' ]]; then
        if [[ ${#matching_pipelines[@]} -eq 1 ]]; then
            pipeline=${matching_pipelines[0]}
        elif [[ ${#matching_pipelines[@]} -eq 0 ]]; then
            echo " found 0 matches for '${query}'. Available pipelines are:"
            for p in "${top_level_pipelines[@]}"; do
                echo " - ${p}"
            done
            for p in "${pipelines[@]}"; do
                echo " - ${p}"
            done
            exit 1
        else
            echo " found ${#matching_pipelines[@]} matches for '${query}':"
            for p in "${matching_pipelines[@]}"; do
                echo " - ${p}"
            done
            exit 1
        fi
    fi

    echo " found ${pipeline}"

    config_path=${pipeline_dir}${pipeline}

    if [[ "$pipeline" == pws* ]]; then
        TARGET="${TARGET:-pws}"
    else
        TARGET="${TARGET:-log-cache}"
    fi

    pipeline_name=$(echo "${pipeline}" | sed 's/\//-/g' | sed 's/.yml//' | sed 's/.erb//')
}

function validate_usage {
    if [ "$pipeline" = "-h" ] || [ "$pipeline" = "--help" ] || [ -z "$pipeline" ]; then
        print_usage
        exit 1
    fi
}

function validate_pipeline {
    echo -n "Validating '${pipeline}' pipeline ... "

    fly -t ${TARGET} validate-pipeline -c ${config_path}
    pipeline_valid=$?

    return $pipeline_valid
}

function sync_fly {
    fly -t $TARGET sync
}

function login_fly {
    echo -n "Checking concourse auth status for '${TARGET}' ... "

    if [[ `fly -t $TARGET status` != 'logged in successfully' ]]; then
        fly -t $TARGET login -b
    else
        success "already logged in"
    fi
}

function preprocess_pipeline {
    if [[ "${pipeline}" == *".erb" ]]; then
        echo -n "Preprocessing erb pipeline ... "
        command -v erb >/dev/null 2>&1 || { echo >&2 "To process .erb pipelines, erb is required but not installed."; exit 1; }

        tmpfile=$(mktemp)
        erb ${config_path} > ${tmpfile}
        config_path=${tmpfile}

        success "processed"
    fi
}

function reconfigure_pipeline {
    echo "Reconfiguring '${pipeline_name}' pipeline ..."

    reconfigure-pipeline \
      --target ${TARGET} \
      --pipeline ${pipeline_name} \
      --config ${config_path} \
      --load-vars-from config/env-config.yml
}

function print_usage {
    echo "usage: $0 <pipeline>"
}

function deprecation_warning {
    query=${1}

    if [[ "${query}" = "log-cache" ]]; then
        warning "NOTICE: the log-cache pipeline was renamed to acceptance.  Try that one instead ;)"
        exit 1
    fi
}

function cleanup {
    if [[ "${pipeline}" == *".erb" ]]; then
        rm ${tmpfile}
    fi
}

function main {
    deprecation_warning $1
    check_lpass
    find_pipeline $1
    validate_usage
    sync_fly
    login_fly
    preprocess_pipeline
    validate_pipeline

    if [ $? -eq 0 ]; then
        reconfigure_pipeline
    fi

    cleanup
}

main $1
